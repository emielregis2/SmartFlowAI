# -*- coding: utf-8 -*-
"""
Testy End-to-End (E2E) dla SmartFlowAI

Testuje pe≈Çny interfejs u≈ºytkownika przez Streamlit
- Logowanie/rejestracja
- Dodawanie proces√≥w
- Analiza AI
- Edycja i usuwanie
- Export PDF

Autor: Claude + Dariusz
"""

import pytest
import os
import sys
import time
from unittest.mock import Mock, patch, MagicMock
from streamlit.testing.v1 import AppTest

# Setup path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

class TestE2ELogin:
    """Testy E2E logowania i rejestracji"""
    
    def setup_method(self):
        """Setup przed ka≈ºdym testem"""
        os.environ['OPENAI_API_KEY'] = 'test-key-12345'
        os.environ['SUPABASE_URL'] = 'https://test.supabase.co'
        os.environ['SUPABASE_ANON_KEY'] = 'test-anon-key-12345'
    
    @patch('streamlit_app.supabase')
    def test_login_flow(self, mock_supabase):
        """Test przep≈Çywu logowania"""
        # Mock successful login
        mock_response = Mock()
        mock_response.user = Mock()
        mock_response.user.email = "test@smartflowai.com"
        mock_supabase.auth.sign_in_with_password.return_value = mock_response
        
        # Inicjalizuj aplikacjƒô
        at = AppTest.from_file("streamlit_app.py")
        at.run()
        
        # Sprawd≈∫ czy pokazuje formularz logowania
        assert len(at.text_input) >= 2  # Email i has≈Ço
        assert len(at.button) >= 1  # Przycisk logowania
        
        # Symuluj wprowadzenie danych
        at.text_input[0].set_value("test@smartflowai.com")  # Email
        at.text_input[1].set_value("test123")  # Has≈Ço
        
        # Kliknij logowanie
        at.button[0].click()
        at.run()
        
        # Po zalogowaniu powinien pokazaƒá dashboard
        # (Sprawdzenie zale≈ºy od struktury aplikacji)
    
    @patch('streamlit_app.supabase')
    def test_registration_flow(self, mock_supabase):
        """Test przep≈Çywu rejestracji"""
        # Mock successful registration
        mock_response = Mock()
        mock_response.user = Mock()
        mock_response.user.email = "newuser@smartflowai.com"
        mock_supabase.auth.sign_up.return_value = mock_response
        
        at = AppTest.from_file("streamlit_app.py")
        at.run()
        
        # Test rejestracji (je≈õli jest dostƒôpna w interfejsie)
        # Implementacja zale≈ºy od struktury formularza

class TestE2EProcessManagement:
    """Testy E2E zarzƒÖdzania procesami"""
    
    def setup_method(self):
        """Setup z zalogowanym u≈ºytkownikiem"""
        os.environ['OPENAI_API_KEY'] = 'test-key-12345'
        os.environ['SUPABASE_URL'] = 'https://test.supabase.co'
        os.environ['SUPABASE_ANON_KEY'] = 'test-anon-key-12345'
    
    @patch('streamlit_app.supabase')
    @patch('streamlit_app.openai_client')
    def test_add_process_flow(self, mock_openai, mock_supabase):
        """Test dodawania nowego procesu"""
        # Mock zalogowanego u≈ºytkownika
        with patch('streamlit_app.st') as mock_st:
            mock_st.session_state.user = "test@smartflowai.com"
            
            # Mock AI response
            mock_ai_response = Mock()
            mock_ai_response.choices = [Mock()]
            mock_ai_response.choices[0].message.content = """
üîç **ANALIZA:** Proces wymaga automatyzacji
üõ†Ô∏è **ROZWIƒÑZANIE:** Zapier + iFirma
üí∞ **KOSZT:** 300 z≈Ç/mies
‚è±Ô∏è **OSZCZƒòDNO≈öCI:** 15 godzin/mies
‚ö° **PIERWSZE KROKI:** 1. Analiza 2. Wdro≈ºenie
"""
            mock_openai.chat.completions.create.return_value = mock_ai_response
            
            # Mock database save
            mock_save_result = Mock()
            mock_save_result.data = [{'id': 1}]
            mock_supabase.table.return_value.insert.return_value.execute.return_value = mock_save_result
            
            # Inicjalizuj aplikacjƒô
            at = AppTest.from_file("streamlit_app.py")
            at.run()
            
            # Znajd≈∫ formularz dodawania procesu
            # (Implementacja zale≈ºy od struktury interfejsu)
            
            # Sprawd≈∫ czy formularz zawiera wymagane pola
            process_title_inputs = [inp for inp in at.text_input if "nazwa" in inp.label.lower() or "title" in inp.label.lower()]
            process_desc_inputs = [inp for inp in at.text_area if "opis" in inp.label.lower() or "desc" in inp.label.lower()]
            
            if process_title_inputs and process_desc_inputs:
                # Wype≈Çnij formularz
                process_title_inputs[0].set_value("Wystawianie faktur")
                process_desc_inputs[0].set_value("Rƒôczne tworzenie faktur w Excelu")
                
                # Znajd≈∫ przycisk analizy
                analyze_buttons = [btn for btn in at.button if "analiz" in btn.label.lower()]
                if analyze_buttons:
                    analyze_buttons[0].click()
                    at.run()
                    
                    # Sprawd≈∫ czy pokazuje wyniki analizy
                    # (Sprawdzenie zale≈ºy od implementacji)
    
    @patch('streamlit_app.supabase')
    def test_process_list_display(self, mock_supabase):
        """Test wy≈õwietlania listy proces√≥w"""
        with patch('streamlit_app.st') as mock_st:
            mock_st.session_state.user = "test@smartflowai.com"
            
            # Mock processes data
            mock_processes = [
                {
                    'id': 1,
                    'title': 'Proces 1',
                    'description': 'Opis procesu 1',
                    'ai_analysis': 'Analiza procesu 1',
                    'created_at': '2025-01-01T00:00:00Z'
                },
                {
                    'id': 2,
                    'title': 'Proces 2',
                    'description': 'Opis procesu 2',
                    'ai_analysis': 'Analiza procesu 2',
                    'created_at': '2025-01-02T00:00:00Z'
                }
            ]
            
            mock_result = Mock()
            mock_result.data = mock_processes
            mock_supabase.table.return_value.select.return_value.eq.return_value.order.return_value.execute.return_value = mock_result
            
            at = AppTest.from_file("streamlit_app.py")
            at.run()
            
            # Sprawd≈∫ czy procesy sƒÖ wy≈õwietlane
            # (Implementacja zale≈ºy od struktury interfejsu)

class TestE2EAdvancedFeatures:
    """Testy E2E zaawansowanych funkcji"""
    
    @patch('streamlit_app.supabase')
    def test_process_editing(self, mock_supabase):
        """Test edycji procesu"""
        with patch('streamlit_app.st') as mock_st:
            mock_st.session_state.user = "test@smartflowai.com"
            
            # Mock process data
            mock_process = {
                'id': 1,
                'title': 'Stary tytu≈Ç',
                'description': 'Stary opis',
                'ai_analysis': 'Stara analiza'
            }
            
            # Mock check ownership
            mock_check_result = Mock()
            mock_check_result.data = [{'id': 1}]
            
            # Mock update
            mock_update_result = Mock()
            
            mock_supabase.table.return_value.select.return_value.eq.return_value.eq.return_value.execute.return_value = mock_check_result
            mock_supabase.table.return_value.update.return_value.eq.return_value.execute.return_value = mock_update_result
            
            # Test edycji przez interfejs
            # (Implementacja zale≈ºy od struktury interfejsu)
    
    @patch('streamlit_app.supabase')
    def test_process_deletion(self, mock_supabase):
        """Test usuwania procesu"""
        with patch('streamlit_app.st') as mock_st:
            mock_st.session_state.user = "test@smartflowai.com"
            
            # Mock check ownership
            mock_check_result = Mock()
            mock_check_result.data = [{'id': 1}]
            
            # Mock deletion
            mock_delete_result = Mock()
            
            mock_supabase.table.return_value.select.return_value.eq.return_value.eq.return_value.execute.return_value = mock_check_result
            mock_supabase.table.return_value.delete.return_value.eq.return_value.execute.return_value = mock_delete_result
            
            # Test usuwania przez interfejs
            # (Implementacja zale≈ºy od struktury interfejsu)

class TestE2EPDFGeneration:
    """Testy E2E generowania PDF"""
    
    @patch('streamlit_app.supabase')
    def test_pdf_generation_flow(self, mock_supabase):
        """Test generowania PDF"""
        with patch('streamlit_app.st') as mock_st:
            mock_st.session_state.user = "test@smartflowai.com"
            
            # Mock processes for PDF
            mock_processes = [
                {
                    'id': 1,
                    'title': 'Proces testowy',
                    'description': 'Opis procesu testowego',
                    'ai_analysis': 'Analiza procesu testowego',
                    'created_at': '2025-01-01T00:00:00Z'
                }
            ]
            
            mock_result = Mock()
            mock_result.data = mock_processes
            mock_supabase.table.return_value.select.return_value.eq.return_value.order.return_value.execute.return_value = mock_result
            
            at = AppTest.from_file("streamlit_app.py")
            at.run()
            
            # Znajd≈∫ przycisk generowania PDF
            pdf_buttons = [btn for btn in at.button if "pdf" in btn.label.lower()]
            
            if pdf_buttons:
                # Test klikniƒôcia przycisku PDF
                pdf_buttons[0].click()
                at.run()
                
                # Sprawd≈∫ czy nie ma b≈Çƒôd√≥w
                # (Sprawdzenie zale≈ºy od implementacji)

class TestE2EUserExperience:
    """Testy E2E do≈õwiadczenia u≈ºytkownika"""
    
    def test_responsive_interface(self):
        """Test responsywno≈õci interfejsu"""
        at = AppTest.from_file("streamlit_app.py")
        at.run()
        
        # Sprawd≈∫ podstawowe elementy interfejsu
        assert len(at.title) >= 1  # Tytu≈Ç aplikacji
        
        # Sprawd≈∫ czy nie ma b≈Çƒôd√≥w w interfejsie
        assert len(at.exception) == 0
    
    def test_navigation_flow(self):
        """Test nawigacji miƒôdzy zak≈Çadkami"""
        with patch('streamlit_app.st') as mock_st:
            mock_st.session_state.user = "test@smartflowai.com"
            
            at = AppTest.from_file("streamlit_app.py")
            at.run()
            
            # Sprawd≈∫ czy sƒÖ dostƒôpne zak≈Çadki
            # (Implementacja zale≈ºy od struktury interfejsu)
    
    @patch('streamlit_app.supabase')
    @patch('streamlit_app.openai_client')
    def test_error_handling_ui(self, mock_openai, mock_supabase):
        """Test obs≈Çugi b≈Çƒôd√≥w w interfejsie"""
        with patch('streamlit_app.st') as mock_st:
            mock_st.session_state.user = "test@smartflowai.com"
            
            # Mock b≈Çƒôdu AI
            mock_openai.chat.completions.create.side_effect = Exception("API Error")
            
            # Mock b≈Çƒôdu bazy danych
            mock_supabase.table.return_value.insert.return_value.execute.side_effect = Exception("DB Error")
            
            at = AppTest.from_file("streamlit_app.py")
            at.run()
            
            # Sprawd≈∫ czy aplikacja nie crashuje przy b≈Çƒôdach
            # (Implementacja zale≈ºy od obs≈Çugi b≈Çƒôd√≥w)

class TestE2EPerformance:
    """Testy E2E wydajno≈õci"""
    
    def test_app_startup_time(self):
        """Test czasu uruchamiania aplikacji"""
        start_time = time.time()
        
        at = AppTest.from_file("streamlit_app.py")
        at.run()
        
        end_time = time.time()
        startup_time = end_time - start_time
        
        # Aplikacja powinna uruchomiƒá siƒô w rozsƒÖdnym czasie (< 10 sekund)
        assert startup_time < 10.0, f"Aplikacja uruchamia≈Ça siƒô zbyt d≈Çugo: {startup_time:.2f}s"
    
    @patch('streamlit_app.supabase')
    def test_large_dataset_handling(self, mock_supabase):
        """Test obs≈Çugi du≈ºej ilo≈õci danych"""
        with patch('streamlit_app.st') as mock_st:
            mock_st.session_state.user = "test@smartflowai.com"
            
            # Mock du≈ºej ilo≈õci proces√≥w
            mock_processes = []
            for i in range(100):
                mock_processes.append({
                    'id': i,
                    'title': f'Proces {i}',
                    'description': f'Opis procesu {i}' * 10,  # D≈Çugi opis
                    'ai_analysis': f'Analiza procesu {i}' * 20,  # D≈Çuga analiza
                    'created_at': f'2025-01-{i%30+1:02d}T00:00:00Z'
                })
            
            mock_result = Mock()
            mock_result.data = mock_processes
            mock_supabase.table.return_value.select.return_value.eq.return_value.order.return_value.execute.return_value = mock_result
            
            start_time = time.time()
            
            at = AppTest.from_file("streamlit_app.py")
            at.run()
            
            end_time = time.time()
            processing_time = end_time - start_time
            
            # Przetwarzanie du≈ºej ilo≈õci danych powinno byƒá rozsƒÖdnie szybkie
            assert processing_time < 15.0, f"Przetwarzanie du≈ºej ilo≈õci danych trwa≈Ço zbyt d≈Çugo: {processing_time:.2f}s"

# Pomocnicze funkcje testowe
def simulate_user_input(at, field_label, value):
    """Symuluje wprowadzenie danych przez u≈ºytkownika"""
    for input_field in at.text_input:
        if field_label.lower() in input_field.label.lower():
            input_field.set_value(value)
            return True
    return False

def find_button_by_text(at, button_text):
    """Znajduje przycisk po tek≈õcie"""
    for button in at.button:
        if button_text.lower() in button.label.lower():
            return button
    return None

# Fixtures dla test√≥w E2E
@pytest.fixture
def mock_logged_user():
    """Mock zalogowanego u≈ºytkownika"""
    with patch('streamlit_app.st') as mock_st:
        mock_st.session_state.user = "test@smartflowai.com"
        yield mock_st

@pytest.fixture
def mock_environment_e2e():
    """Mock ≈õrodowiska dla test√≥w E2E"""
    with patch.dict(os.environ, {
        'OPENAI_API_KEY': 'test-openai-key-e2e',
        'SUPABASE_URL': 'https://test-e2e.supabase.co',
        'SUPABASE_ANON_KEY': 'test-supabase-key-e2e'
    }):
        yield

# Uruchomienie test√≥w E2E
if __name__ == "__main__":
    print("üöÄ Uruchamianie test√≥w End-to-End SmartFlowAI...")
    pytest.main([__file__, "-v", "--tb=short", "-x"])  # -x = stop on first failure 